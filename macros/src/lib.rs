extern crate proc_macro as proc;

mod calcurs_scope;
mod parsers;
mod utils;

use calcurs_scope::CalcursMacroScope;
use proc_macro2::{Span, TokenStream};
use quote::{quote, ToTokens};
use syn::{
    parse::{Parse, Parser},
    parse_macro_input, Error, Field, ItemStruct, ItemTrait,
};
use utils::*;

#[allow(unused_imports)]
// needed because of doclink bug
use calcurs_internals::Inherited;

/// This macro gets as input a type and will insert a field called base with that type it will also implement the [Inherited] trait
#[proc_macro_attribute]
pub fn inherit(attrib: proc::TokenStream, item: proc::TokenStream) -> proc::TokenStream {
    let item = parse_macro_input!(item as ItemStruct);
    let base_type = parse_macro_input!(attrib as syn::Type);

    let struct_name = &item.ident.clone();
    let struct_generics = &item.generics.clone();

    let base = Field::parse_named
        .parse2(quote! {base: #base_type})
        .expect("inherit: could not implemnt base field");

    let internals = import_crate("internals");

    let item = append_field(item, base);

    if let Err(err) = item {
        return err.into_compile_error().into();
    }

    let item = item.unwrap();

    quote! {
        #item

        impl #struct_generics #internals::Inherited<#base_type> for #struct_name #struct_generics {
            fn base(&self)  -> &#base_type {
                &self.base
            }
        }

    }
    .into()
}

/// Modifies the tokens based on the attributes used, e.g: [macro@calcurs_type] \
/// strips the module and inserts the modified [TokenStream]
///
/// a attribute macro + a mod was used, because: \
/// - function-like macros messed with the lsp \
/// - inner attribute macros are unstable
#[proc_macro_attribute]
pub fn init_calcurs_macro_scope(
    _: proc::TokenStream,
    item: proc::TokenStream,
) -> proc::TokenStream {
    let scope = parse_macro_input!(item as CalcursMacroScope);
    scope.into_token_stream().into()
    // let input: syn::ItemMod = parse_macro_input!(item as syn::ItemMod);

    // let input = parse_macro_input!(item as syn::ItemMod);

    // if input.content.is_none() {
    //     return input.to_token_stream().into();
    // }

    // let items = input.content.unwrap().1;

    // let items: Vec<_> = items
    //     .into_iter()
    //     .map(|item| Rc::new(RefCell::new(item)))
    //     .collect();

    // let mut stream = match parse_calcurs_scope(&items) {
    //     Ok(s) => s,
    //     Err(e) => return e.into_compile_error().into(),
    // };

    // items
    //     .iter()
    //     .for_each(|item| item.borrow().to_tokens(&mut stream));

    // stream.into()
}

/// struct marked with this attribute will be turned into CalcursTypes
///
/// this includes the following actions: \
/// add a base field of type defined by [macro@calcurs_base] and implement [Inherited]
#[proc_macro_attribute]
pub fn calcurs_type(_: proc::TokenStream, _: proc::TokenStream) -> proc::TokenStream {
    return Error::new(
        Span::call_site().into(),
        "called attribute calcurs_type outside a calcurs_scope",
    )
    .into_compile_error()
    .into();
}

/// traits marked with this attribute will be turned into CalcursTraits
#[proc_macro_attribute]
pub fn calcurs_trait(_: proc::TokenStream, _: proc::TokenStream) -> proc::TokenStream {
    return Error::new(
        Span::call_site().into(),
        "called attribute calcurs_trait outside a calcurs_scope",
    )
    .into_compile_error()
    .into();
}

/// can only be defined once per calcurs_macro_scope. the [macro@calcurs_type] macro will use the marked
/// struct as the base
#[proc_macro_attribute]
pub fn calcurs_base(_: proc::TokenStream, _: proc::TokenStream) -> proc::TokenStream {
    return Error::new(
        Span::call_site().into(),
        "called attribute calcurs_base outside a calcurs_scope",
    )
    .into_compile_error()
    .into();
}

#[proc_macro_attribute]
pub fn dyn_trait(_: proc::TokenStream, input: proc::TokenStream) -> proc::TokenStream {
    let mut input = parse_macro_input!(input as ItemTrait);

    let trait_name = &input.ident;
    let dyn_trait_name = quote::format_ident!("Dyn{}", trait_name);

    let doc = format!(
        "Allows for trait object: dyn [{}] to be cloned and compared.\n\n
Generated by [macros::dyn_trait]
        ",
        trait_name
    );

    let dyn_trait = quote! {
        #[doc = #doc]
        pub trait #dyn_trait_name {
            fn dyn_clone(&self) -> Box< dyn #trait_name >;
            fn as_any(&self) -> &dyn Any;
            fn dyn_eq(&self, _: &dyn #trait_name ) -> bool;
        }

        impl<T: #trait_name + Clone + PartialEq + 'static> #dyn_trait_name for T {

            fn dyn_clone(&self) -> Box<dyn #trait_name> {
                Box::new(self.clone())
            }

            fn as_any(&self) -> &dyn Any {
                self
            }

            fn dyn_eq(&self, other: &dyn #trait_name) -> bool {
                #dyn_trait_name::as_any(other)
                    .downcast_ref::<T>()
                    .map_or(false, |x| self == x)
            }
        }

        impl Clone for Box<dyn #trait_name> {
            fn clone(&self) -> Box<dyn #trait_name> {
                #dyn_trait_name::dyn_clone(self.as_ref())
            }
        }

        impl PartialEq for dyn #trait_name {
            fn eq(&self, other: &dyn #trait_name) -> bool {
                #dyn_trait_name::dyn_eq(self, other)
            }
        }


    };

    let trait_bound = syn::TypeParamBound::parse
        .parse2(quote! { #dyn_trait_name })
        .expect(&format!(
            "could not parse {} as trait bound",
            quote!(#dyn_trait_name)
        ));

    input.supertraits.push(trait_bound.into());

    let mut stream = TokenStream::new();
    dyn_trait.to_tokens(&mut stream);
    input.to_tokens(&mut stream);

    stream.into()
}
